---
layout: post
title: "DDDQ - 요약 (1)"
date: "2015-10-09 12:24"
tags:
  - "ddd"
---

> **DDDQ(Domain Driven Design Quickly) - 도메인 주도 설계란 무엇인가?**
>
> 라는 책의 간단 요약 정리

# 도메인 주도 설계란 무엇인가?

**소프트웨어 개발이 어려운 이유는 현실세계 문제의 복잡성에서 시작된다**

**도메인**

- 자동화된 비즈니스 프로세스
- 현실세계의 문제
- 하나의 도메인은 세상의 **어떤 것**
- **그래서 복잡함** - 본질적 복잡성

> 본질적 복잡성, 우연적복잡성
>
> - 본질적(필연적) 복잡성 : 소프트웨어 구현하고자 하는 기능에 대한 복잡성
> - 우연적 복잡성 : 소프트웨어를 구현하는 행위(언어, 툴, 라이브러리 등)에 따른 복잡성

**도메인 모델**

- 소프트웨어 기능을 위해서 도메인 전문가의 지식에서 선택적으로 추상화하여 엄격하게 조직화한 것
- 다이어그램 등으로 전달하고자하는 아이디어
  - 다이어그램이나 그림은 모델을 가시적으로 표현하고 전달하는 역할일 뿐
- 복잡성을 다루는 도구이자 추상화의 결과
- 도메인 전문가와 개발자(개발자들 간에도) 사이의 소통의 중심
  - 지속적인 피드백이 가능하고 최신상태를 유지해야 의미가 있다.
  - 기능(요구사항) - 도메인 모델(유연한 설계) - 구현이 자연스럽게 연결. 즉, 기능과 구현의 자연스로운 통로
  - 소프트웨어 구현에 자연스럽게 녹아들어야 한다.

**도메인 전문가** : 현실세계의 문제(업무)를 가장 잘 이해하는 해당분야 전문가 (ex:은행원, 항공관제사 등)

**개발자** : 설계자, 개발자 등 소프트웨어를 구축하는 이

**소프트웨어**

- 소프트웨어는 도메인의 핵심개념과 각 구성요소를 담고 있어야 하고 그들 간의 관계를 정확하게 실체화해야 한다.
- 소프트웨어는 도메인을 모델링해야 한다

**(도메인 모델을 통한) 좋은 설계는 개발을 가속화 하고, 동시에 개발 프로세스에서 받는 피드백이 설계를 강화한다.**

### 도메인 지식 쌓기

**일반화(Generalization)**

- 추상화의 한 기법
- 공통적인 부분을 골라내는 것

**개념 (Concept)**

- Type


도메인에 대한 개발자의 분석적인 자세는 도메인 전문가들과 토의하는 도중에 도메인의 **핵심 개념(Concept)** 을 발굴해 내는데 도움이 된다.

개발자와 도메인 전문가들은 도메인 모델을 **함께** 만들어 낸다.

도메인과 소프트웨어는 **도메인 모델을 통해서** 철저하게 혼합되어야 한다.

# 유비쿼터스 언어

### 공통 언어의 필요성

**공통 언어가 없다면?**

- 각 전문 분야 용어와 서로 다른 언어에 따른 의사소통이 어려움
- **번역 비용**
  - 예를 들어 개발자는 A 라는 용어를 쓰는데 도메인 전문가는 이해가 안되므로 도메인 전문가에게 설명을 위한 다른 용어로 표현
  - 번역 자체 비용 뿐만 아니라 용어의 혼재까지 발생해서 복잡도가 상승함
- 자신만의 방언

**솔루션**

- 도메인 모델 기반 언어 : 모델을 표현할 때 사용하는 용어
- 다이어그램에 적혀진 언어를 프로젝트 의사소통 시에도 **소리내어** 사용
- 이 언어를 **유비쿼터스 언어(보편 언어)** 라 부른다.

**만약 해당 언어나 모델을 도메인 전문가가 잘 이해하지 못하면 그 부분은 잘못되어 있을 가능성이 매우 높다.**

### 유비쿼터스 언어 만들기

**항공기 관제 예제의 용어와 핵심개념**

1. 비행기, 출발지, 목적지
2. 비행기, 항로
3. 비행기, 항로, 고정지점, 위도, 고도
4. 비행기, 항로, 고정지점, 위도, 고도, 비행계획, 속도
5. 비행, 비행계획, 항로, 고정지점, 2차원 좌표

**결론** : 개발자, 도메인 전무가로 구성된 설계팀은 자신들의 행동을 통합하고, 모델 작성과 작성된 모델의 코드화를 도와줄 언어가 필요하다


# 모델 주도 설계

**프로젝트 진행 과정을 도메인 모델을 통해서 밀접하게 연결시킨다.**

기능, 분석, 설계, 구현등의 일련의 과정이 **도메인 모델** 을 통해서 이루어지고 상호 간 피드백이 활성화되어야 한다.
여기에 **유비쿼터스 언어** 를 적극적으로 사용한다.
또한, 코드는 모델을 밀접하게 반영한다.

도메인 모델 주도 설계를 이용하여 구현 시 OOP가 적합하다.

### 모델 주도 설계를 위한 블록

![MODEL-DRIVEN DESIGN의 언어로 구성된 내비게이션 맵](/images/2015/10/ddd-diagram.png)

*이미지출처 : http://www.infoq.com/minibooks/domain-driven-design-quickly*


### 계층형 아키텍처

![Layred Architecture](/images/2015/10/DDDQ-layeredArchitecture.png)

*이미지출처 : http://wikibook.co.kr/article/layered-architecture/*

복잡성 제거를 위해서 레이어로 분할

- 레이어 내 응집력 강화
- 하위 레이어에만 의존적
- 도메인 레이어를 두어서 도메인 자체 표현에 집중

1. 사용자 인터페이스 (Presentation) : 표현
2. 애플리케이션 레이어 (Service) : 위임, 처리
3. 도메인 레이어 (Domain) : 비즈니스로직, 상태
4. 인프라스트럭처 레이어 (Repository 등) : 영속화, 통신 등

### 엔티티(Entity)

- 연속성 : 동일한 객체의 상태가 생명주기 내에서 변화하는 것
- 유일성 : 생명주기 내 객체가 유일하게 지속될 수 있게 하는 것, 유일한 식별자 존재

*엔티티의 구현 : 식별자를 만들어 내는 작업*

DB테이블의 주식별자로 엔티티의 식별자를 만들어도 된다. - 주로 이렇게 한다.

### 값 객체(Value Object)

**정의** : 도메인의 어떠한 측면을 표현하는 데 사용되지만 식별자가 없는 객체.
주로 수치와 같은 상대적으로 단순한 값을 표현하고 불변성(수정할 수 없음)을 가짐

- 값 객체는 라이프사이클을 신경쓰지 않아도 된다. 즉 쉽게 생성되고 폐기할 수 있다.
- 불변 객체
  - 만약 변경이 필요하다면 새로 만들거나 복사해서 변경한 후 반환한다 - _방어 복사_
  - 참조 : http://download.oracle.com/global/kr/magazine/23winter_tech2.pdf

**엔티티와 대조**

- 불변 != 상태가 변함 = 연속성
- 식별자가 필요없음 != 식별자가 필요함 = 유일성

값 객체 자체로는 의미가 약하다. Entity 속성으로 많이 쓰이고 엔티티와 함께 존재할 때 완전한 의미를 가진다.

### 서비스(Service)

- 인터페이스 행위(operation)와 위임
- 도메인 객체의 행위로 포함하기 힘든 경우 서비스 행위로 정의 - 즉 도메인 객체의 역할로 할당하기 힘든 경우
- 역으로 도메인 객체에 속하는 역할을 서비스 행위로 만들면 안된다 - 서비스 역할이 도메인 영역을 심하게 침범하면 계층 간 강결합이 일어난다.
- 어떤 행위(계좌이체)에 대한 도메인 객체 간(송금계좌와 입금계좌) 느슨한 결합

**특징**

1. 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다.
2. 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다.
3. 오퍼레이션은 상태를 저장하지 않는다. (stateless)

### 모듈(Module)

**도메인 모델의 구조화된 일부분**

**모듈화** : 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법

- 모듈 기반 높은 응집도 > 모듈 간 결합도는 낮아짐
  - 통신 응집도 : 같은 데이타
  - 기능 응집도 : 유사한 행위

모듈에 유비쿼터스 언어로 된 이름을 부여하라

### 집합(Aggregate)

**관계의 단순화**

1. 모델의 핵심 사항이 아닌 관계가 있다면 그 관계를 제거한다.
2. 다수성(N)의 숫자는 제약사항(constraint)-또는 한정자(qualifier)-을 추가하여 감소시킨다
3. 많은 경우 양방향 관계는 단방향 관계로 대처될 수 있다.

관계의 단순화를 거친다고 할 지라도 객체 사이에는 아직도 많은 복잡한 관계가 존재한다.
여기에서 모든 객체의 관계가 일관성을 유지하는 것은 매우 어렵다.

**관계의 일관성**

- 데이터 무결성 보장
- 불변식?? 강제

**집합으로 관계의 일관성을 유지하자**

- 각 집합은 하나의 root를 지닌다.
- `root`는 엔티티
- `root`는 집합된 다른 객체들에 대한 참조를 가지고 있다.
- `root`를 통해서만 객체의 외부에서 접근가능
  - 즉, 다른 객체들은 집합에 속한 객체들을 직접 변경할 수가 없음
  - 오직 `root`를 통해서면 내부 객체들의 변경을 요청할 수 있음
  - `root`를 통한 행위는 제어가 가능하다. - 이 제어를 통해서 **관계의 일관성** 을 유지할 수 있다.
  - 만약 외부에서 내부 객체의 참조를 요청하면 복사해서 전달하면 된다. - *방어 복사*

*예제*
// TODO 다이어그램 추가

### 팩토리

// TODO 작성중
