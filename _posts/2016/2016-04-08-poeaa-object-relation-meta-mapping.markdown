---
layout: post
title: "POEAA : 객체-관계형 메타데이터 매핑 패턴"
date: '2016-04-08 00:30'
tags:
  - book
  - POEAA
---

# 메타데이터 매핑

_객체-관계형 매핑의 세부 정보를 메타데이터로 저장한다._

![Meta data mapping](/attach/2016/POEAA/ClassDiagram-MetaData.png)

## 방식

1. 코드 생성
    2. 코드생성 클래스를 직접 생성하는 것과 차이가 없다.
    3. 속도가 빠르나 변경에 유연하지 않다.
    4. 하지만 CTW 같은 것을 사용한다면!!!
2. 리플렉션 방식
    3. 변경에는 유연하나 속도가 느릴 수 있다.

## 메타데이터

- 일반적으로 별도의 파일 형식을 사용함 - XML
- 직접 소스코드로 표현할 수도 있음
- DB로 관리

## 이유

메타데이터 매핑을 이용하면 **데이터베이스 매핑 작업** 을 크게 간소화할 수 있다.
대신 메타데이터 매핑을 프레임워크를 준비하는 작업이 필요하다.

> MyBatis의 `ResultMap` 그것과 비슷하다.

# 쿼리 객체

_데이터베이스 쿼리를 나타내는 객체_

[인터프리터][fe8fa48d][GoF] 역할을 한다. 객체의 구조를 바탕으로 SQL 쿼리를 구성할 수 있게 해준다.

  [fe8fa48d]: https://en.wikipedia.org/wiki/Interpreter_pattern "인터프리터 패턴"

- SQL
- Composite pattern
- DSL

## 구현

쿼리 객체의 기본은 데이터베이스의 스키마가 아니라 인메모리 객체를 기준으로 쿼리를 표현하는 것이다.
고로 **메타데이터 매핑(325)** 가 필요하다.

## 장점

- 데이터베이스 스키마 캡슐화
    - 다중 데이터베이스 지원
    - 다중 스키마 지원
- 중복 쿼리 방지

대부분의 프로젝트는 모든 쿼리 기능을 필요하지 않으므로 제한된 **쿼리 객체** 만으로 충족할 수 있다.
추가 스팩이 생기면 그 때 반영해도 늦지 않다.

# 리포지토리

_도메인 객체에 접근하는 컬렉션과 비슷한 인터페이스를 사용해 도메인과 데이터 매핑 계층 사이를 중재한다._

Persistence 계층에 대한 좀 더 객체지향적 관점을 제공한다. 또한 도메인과 데이터 매핑 계층 간의 깔끔한
분리와 단방향 의존성의 목표를 달성하도록 지원한다. (데이터 매핑 캡슐화)

리포지토리는 순수한 객체지향 방식으로 수행할 수 있게 캡슐화 하는 사양패턴(Specification pattern)을
촉진힌다. 그래서 특정한 사례에 맞게 쿼리 객체를 설정하는 코드를 모두 제거할 수 있다. 또한 클라이언트는
SQL을 직접 다루지 않고 순수한 객체의 관점에서 코드를 작성할 수 있다.

단위테스트도 간단하게 할 수 있다.

DB를 조회하는 것이라 인메모리 객체 콜랙션을 사용한다는 느낌이 들 것이다.

> [Specification pattern][e30c03da] 을 참고 요망

  [e30c03da]: https://en.wikipedia.org/wiki/Specification_pattern "Specification pattern"
