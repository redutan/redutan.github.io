---
layout: post
title: POEAA : 객체-관계형 구조 패턴 (2)
date: '2016-03-31 00:41'
tags:
  - book
  - POEAA
---

# 포함 값(Embedded Value)

_한 객체를 다른 객체의 테이블에 있는 여러 필드로 매핑한다_

![포함 값](/attach/2016/POEAA/ClassDiagram-EmbeddedValue.png)

객체지향에서는 여러 작은 객체를 사용하는 것이 합리적이지만, 데이터베이스 테이블은 여러 작은 객체를
저장하는 데 적합하지 않다.

_의존 매핑_ 에서 의존자가 주로 1:1 관계로 값객체가 되는 특수 사례가 **포함 값** 이다.

- 값객체 (식별자 없음)
- 1:1
- 주로 간단한 의존자

> 직렬화 LOB와 비교할 여지가 많다. 복잡하거나 1:N인 경우에는 직렬화 LOB를 고려하라.

# 직렬화 LOB(Serialized LOB)

![직렬화 LOB](/attach/2016/POEAA/ClassDiagram-SerializedLob.png)

## 구현방법

- BLOB
- CLOB
    - String
    - XML

> 개인적으로 해당 패턴은 매우 특별한 경우 제외하고 다른 방식을 사용하는 것이 낫다고 본다.

# 단일 테이블 상속

_여러 클래스로 이뤄진 상속 계층을 다양한 클래스의 모든 필드에 대한 열을 포함하는 단일 테이블로 나타낸다._

![단일 테이블 상속](/attach/2016/POEAA/ClassDiagram-SingleTable.png)

### 장점

- 한 테이블 만 사용
- No join
- 필드 계층 변경 시 DB스키마 변경 없음

### 단점

- 객체 필드와 DB 칼럼이 연관성이 없는 것들이 있어서 사용에 혼란
- 사용하지 않는 DB 칼럼 낭비 (하지만 대부분 DB벤더별로 빈 칼럼 최적화)
- 인덱스 증가
- DB 칼럼 중복 발생 가능성 - prefix로 구분 가능

> JPA의 단일테이블 상속과 유사

# 클래스 테이블 상속

_각 클래스당 테이블 하나를 사용해 클래스의 상속 계층을 나타낸다_

![클래스 테이블 상속](/attach/2016/POEAA/ClassDiagram-ClassTable.png)

**개인적으로 3가지 중 가장 선호하는 방식**

### 장점

- 테이블 구조 가독성이 좋음
- 공간 낭비 없음
- 도메인 모델과 테이블 간 관계가 직관적

### 단점

- 복잡한 Query
- 필드 계층 변경 시 DB스키마 변경
- 상위 테이블 병목 가능성
- 임시 쿼리(ad hoc query)가 이해하기 어려움

> JPA의 계층테이블 상속과 유사

# 구현 테이블 상속

_클래스의 상속 계층을 계층의 구현 클래스당 테이블 하나를 사용해 나타낸다._

![구현 테이블 상속](/attach/2016/POEAA/ClassDiagram-ConcreteTable.png)

### 장점

- 테이블이 독립적
- No join
- 부하 분산

### 단점

- 기본키 처리가 힘듬
- 추상 클래스에서 데이터베이스 관계를 강제할 수 없음
- 필드 계층 변경 가능성이 있다 (클래스 테이블 상속 > 구현 테이블 상속 > 단일 테이블 상속)
- 필드 복제로 인한 반정규화
- 상위 클래스에서 검색 시 불필요한 Join 요구

> JPA의 구현테이블 상속과 유사

# 상속 매퍼

_상속 계층을 처리하는 데이터베이스 매퍼를 구성하는 구조_

단일 테이블, 클래스 테이블, 구현 테이블 상속을 이용할 시 구현하는 매퍼
